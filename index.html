<!DOCTYPE html>
<html lang="zh-CN">
<meta charset="UTF-8" />
<title>Soft Boundary Map</title>
<style>
  html,body{margin:0;height:100%}
  /* 居中布局 + 大标题 */
  body{
    display:flex;flex-direction:column;align-items:center;justify-content:center;
    gap:12px;background:#ffffff;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  h1{
    margin-top: 20px;
    font-size:28px;
    font-weight:700;
    letter-spacing:.5px;
    color:#111;
  }
  /* —— 新增：上方注释/图例 —— */
  .legend{
    display:flex;align-items:center;gap:18px;
    font-size:12px;color:#111; user-select:none;
  }
  .legend-item{display:inline-flex;align-items:center;gap:8px}
  .key{display:inline-block;width:16px;height:12px;vertical-align:middle}
  .key.box{background:#fff;border:1px solid #000;border-radius:2px}
  .key.shadow{background:rgba(0,0,0,0.10);filter:blur(2px);border-radius:2px}
  .key.line{width:24px;height:0;border-top:2px solid red}

  /* ======= 容器尺寸可调 ======= */
  #wrap{
    width: 1000px;
    height: 600px;
    border: 1px solid #ddd;
    box-sizing: border-box;
    position: relative;
    background:#effaf2;
    border-radius:12px;
    box-shadow: 0 6px 24px rgba(0,0,0,.06);
  }
  /* SVG 占满容器 */
  #wrap svg{width:100%;height:100%;display:block}
  /* activity 与 “数据(cm)”同款 */
  text.activity,
  text.passer{           /* 确保 passer 文本与其他一致 */
    font-weight:400;
    font-size:10px;
    fill:#000;
    text-anchor:middle;
    dominant-baseline:middle;
    pointer-events:none;
    user-select:none;
  }
</style>
<body>
  <h1>Soft Boundary Map</h1>
  <div class="legend" aria-label="Legend">
    <span class="legend-item"><span class="key box"></span>Facilities</span>
    <span class="legend-item"><span class="key shadow"></span>Soft Boundary Field</span>
    <span class="legend-item"><span class="key line"></span>Field Range Measurement</span>
  </div>
  <div id="wrap">
    <svg id="svg" viewBox="0 0 100 100" preserveAspectRatio="none">
      <defs>
        <filter id="shadowBlur" x="-20%" y="-20%" width="140%" height="140%" filterUnits="objectBoundingBox">
          <feGaussianBlur in="SourceGraphic" stdDeviation="7" />
        </filter>
      </defs>
    </svg>
  </div>

<script>
(() => {
  // ======== 可调参数 ========
  const COUNT_BASE = 7;                 // 基准数量（会随容器面积自适应）
  const SHADOW_ALPHA = 0.1;
  const BLUR_STD = 4;
  const MAX_TRIES = 14000;

  // 影子大小（线性比例）
  const S_MIN = Math.sqrt(16);
  const S_MAX = Math.sqrt(19);

  // 段落时机/概率
  const MOVE_MIN = 6000, MOVE_MAX = 11000;
  const HOLD_MIN = 3000, HOLD_MAX = 7000;
  const START_JITTER = 2000;
  const P_MOVE  = 0.5;
  const P_DRIFT = 0.25;
  const P_HOLD  = 0.25;
  const DRIFT_MAX = Math.PI / 9; // ±20°

  // 像素→厘米映射（容器内的像素）
  const PX_MIN = 105, PX_MAX = 118;
  const CM_MIN = 60,  CM_MAX = 88;

  // 影子内活动数据
  const ACTIVITIES = [
    "Walking","Resting","Exercising","Socializing",
    "Dating","Family outing","Walking the dog","Playing with the dog","Babysitting"
  ];
  const ACT_CHANGE_PROB = 0.5;

  // 静止过路者（最多一个；定期瞬移与换词）
  const PASSERS = ["running","walking","riding bike"];
  const PASSER_PAD = 6;         // 过路者安全边界
  const PASSER_MARGIN = 12;     // 离容器边缘的最小间距
  const PASSER_MIN_MS = 3000;   // 刷新最小间隔
  const PASSER_MAX_MS = 6000;   // 刷新最大间隔

  const wrap = document.getElementById('wrap');
  const svg  = document.getElementById('svg');

  const ro = new ResizeObserver(() => render());
  ro.observe(wrap);

  // —— 过路者全局句柄与定时器 —— //
  let passerEl = null;
  let passerTimer = null;

  function render(){
    // 清空 & 停止旧的过路者计时器
    if (passerTimer){ clearTimeout(passerTimer); passerTimer = null; }
    const defs = svg.querySelector('defs').outerHTML;
    svg.innerHTML = defs;

    const W = wrap.clientWidth;
    const H = wrap.clientHeight;
    svg.setAttribute('viewBox', `0 0 ${W} ${H}`);

    const fe = svg.querySelector('#shadowBlur feGaussianBlur');
    if (fe) fe.setAttribute('stdDeviation', String(BLUR_STD));

    const areaScale = (W * H) / (800 * 600);
    const targetCount = clamp(Math.round(COUNT_BASE * Math.sqrt(areaScale)), 3, 20);

    const baseR = Math.min(W, H) * 0.03;
    const BODY_R_MIN = 1.2, BODY_R_MAX = 1.2;

    const animItems = [];
    const exclusionDisks = []; // 排斥圆（设施中心到最大可能阴影边缘）

    function regularPoly(cx, cy, r, sides, rot){
      const pts = [];
      for(let i=0;i<sides;i++){
        const a = rot + i*(2*Math.PI/sides);
        pts.push([cx + r*Math.cos(a), cy + r*Math.sin(a)]);
      }
      return pts;
    }
    const randRange = (a,b)=>a + Math.random()*(b-a);
    const randInt = (n)=> (Math.random()*n|0);

    function tryPlace(){
      const placed = [];
      let tries = 0;

      while (placed.length < targetCount && tries < MAX_TRIES){
        tries++;

        const bodyR = baseR * randRange(BODY_R_MIN, BODY_R_MAX);
        const sFixed = randRange(S_MIN, S_MAX);
        const shadowR = bodyR * sFixed;

        const sides = 4 + (Math.random()*3|0);
        const rot   = Math.random()*Math.PI;

        const margin = bodyR + shadowR + 2;
        const cx = margin + Math.random()*(W - 2*margin);
        const cy = margin + Math.random()*(H - 2*margin);
        if (cx < bodyR || cx > W - bodyR || cy < bodyR || cy > H - bodyR) continue;

        // 粗碰撞（允许相切）
        let ok = true;
        for (const o of placed){
          const dc = Math.hypot(cx - o.cx, cy - o.cy);
          if (dc < (bodyR + o.bodyR)) { ok=false; break; }
          if (Math.abs(dc - o.bodyR) < (bodyR + o.shadowR)) { ok=false; break; }
          if (Math.abs(dc - bodyR) < (shadowR + o.bodyR)) { ok=false; break; }
          if (dc - (bodyR + o.bodyR) < (shadowR + o.shadowR)) { ok=false; break; }
        }
        if (!ok) continue;

        const absPts = regularPoly(cx, cy, bodyR, sides, rot);
        const relPts = absPts.map(([px,py])=>[px-cx, py-cy]);
        const d = "M" + absPts.map(p=>p.join(",")).join(" L ") + " Z";

        // 影子
        const shadowPath = document.createElementNS("http://www.w3.org/2000/svg","path");
        shadowPath.setAttribute("d", d);
        shadowPath.setAttribute("fill", `rgba(0,0,0,${SHADOW_ALPHA})`);
        shadowPath.setAttribute("filter", "url(#shadowBlur)");
        svg.appendChild(shadowPath);

        // 本体
        const body = document.createElementNS("http://www.w3.org/2000/svg","path");
        body.setAttribute("d", d);
        body.setAttribute("fill", "#fff");
        body.setAttribute("stroke", "#000");
        body.setAttribute("stroke-width", "0.2");
        svg.appendChild(body);

        // 标尺
        const rulerLine = document.createElementNS("http://www.w3.org/2000/svg","line");
        rulerLine.setAttribute("stroke", "red");
        rulerLine.setAttribute("stroke-width", "0.5");
        rulerLine.setAttribute("opacity", "1");
        svg.appendChild(rulerLine);

        const rulerLabel = document.createElementNS("http://www.w3.org/2000/svg","text");
        rulerLabel.setAttribute("fill", "#000");
        rulerLabel.setAttribute("font-size", "10");
        rulerLabel.setAttribute("text-anchor", "middle");
        rulerLabel.setAttribute("dominant-baseline", "middle");
        rulerLabel.setAttribute("opacity", "1");
        svg.appendChild(rulerLabel);

        // 影子内活动文本
        const activityText = document.createElementNS("http://www.w3.org/2000/svg","text");
        activityText.setAttribute("class","activity");
        activityText.textContent = ACTIVITIES[randInt(ACTIVITIES.length)];
        svg.appendChild(activityText);

        // 初始角
        const theta0 = Math.random()*Math.PI*2;
        const sx0 = cx + bodyR*Math.cos(theta0);
        const sy0 = cy + bodyR*Math.sin(theta0);
        shadowPath.setAttribute("transform", `translate(${sx0},${sy0}) scale(${sFixed}) translate(${-cx},${-cy})`);

        // 第一段
        const now = performance.now();
        const {type, target, dur} = pickNextSegment(theta0);
        placed.push({cx,cy, bodyR, shadowR});
        animItems.push({
          shadowPath,
          cx, cy,
          rPath: bodyR,
          thetaStart: theta0,
          thetaTarget: target,
          segT0: now + randRange(0, START_JITTER),
          segDur: dur,
          segType: type,
          sFixed,
          relPts,
          rulerLine, rulerLabel,
          activityText,
          _sx: sx0, _sy: sy0
        });

        // 建立排斥圆：最大可能半径 ≈ bodyR*(1 + sFixed)
        exclusionDisks.push({ cx, cy, R: bodyR * (1 + sFixed) + PASSER_PAD });
      }
      return placed.length === targetCount;
    }

    function pickNextSegment(thetaStart){
      const r = Math.random();
      if (r < P_MOVE){
        return { type: "MOVE",  target: Math.random()*Math.PI*2,      dur: randRange(MOVE_MIN, MOVE_MAX) };
      } else if (r < P_MOVE + P_DRIFT){
        const delta = randRange(-DRIFT_MAX, DRIFT_MAX);
        const TAU = Math.PI*2;
        let target = (thetaStart + delta) % TAU; if (target<0) target += TAU;
        return { type: "DRIFT", target, dur: randRange(MOVE_MIN, MOVE_MAX) };
      } else {
        return { type: "HOLD",  target: thetaStart,                  dur: randRange(HOLD_MIN, HOLD_MAX) };
      }
    }

    // 放置 & 动画
    for (let round=0; round<4; round++){
      const defs2 = svg.querySelector('defs').outerHTML;
      svg.innerHTML = defs2;
      animItems.length = 0;
      exclusionDisks.length = 0;
      if (tryPlace()) { startAnim(); placeStaticPasser(); schedulePasserUpdates(); return; }
    }
    const defs3 = svg.querySelector('defs').outerHTML;
    svg.innerHTML = defs3;
    animItems.length = 0;
    exclusionDisks.length = 0;
    tryPlace();
    startAnim();
    placeStaticPasser();
    schedulePasserUpdates();

    function startAnim(){
      function tick(now){
        for (const it of animItems){
          const phase = now - it.segT0;

          if (phase < 0){
            updateShadowTransform(it, it.thetaStart);
            updateRuler(it);
            updateActivity(it);
            continue;
          }

          const t = Math.min(1, phase / it.segDur);
          const e = easeInOutCubic(t);
          const theta = angleLerpShortest(it.thetaStart, it.thetaTarget, e);

          updateShadowTransform(it, theta);
          updateRuler(it);
          updateActivity(it);

          if (phase > it.segDur){
            it.thetaStart = it.thetaTarget;
            const nxt = pickNextSegment(it.thetaStart);
            it.segType = nxt.type;
            it.thetaTarget = nxt.target;
            it.segDur = nxt.dur;
            it.segT0 = now + randRange(0, 800);

            if (Math.random() < ACT_CHANGE_PROB){
              it.activityText.textContent = ACTIVITIES[randInt(ACTIVITIES.length)];
            }
          }
        }
        requestAnimationFrame(tick);
      }
      requestAnimationFrame(tick);
    }

    // —— 把影子按角度更新到位 —— //
    function updateShadowTransform(it, theta){
      it._sx = it.cx + it.rPath * Math.cos(theta);
      it._sy = it.cy + it.rPath * Math.sin(theta);
      it.shadowPath.setAttribute(
        "transform",
        `translate(${it._sx},${it._sy}) scale(${it.sFixed}) translate(${-it.cx},${-it.cy})`
      );
    }

    // —— 标尺（始终显示） —— //
    function updateRuler(it){
      const far = getFarthestPoint(it.cx, it.cy, it._sx, it._sy, it.sFixed, it.relPts);
      it.rulerLine.setAttribute("x1", it.cx); it.rulerLine.setAttribute("y1", it.cy);
      it.rulerLine.setAttribute("x2", far.x); it.rulerLine.setAttribute("y2", far.y);

      const midx = it.cx + (far.x - it.cx)*0.6, midy = it.cy + (far.y - it.cy)*0.6;
      it.rulerLabel.setAttribute("x", midx); it.rulerLabel.setAttribute("y", midy);
      const cm = clamp(mapRange(far.dist, PX_MIN, PX_MAX, CM_MIN, CM_MAX), CM_MIN, CM_MAX);
      it.rulerLabel.textContent = cm.toFixed(1) + " cm";
    }

    // —— 活动文本 —— //
    function updateActivity(it){
      let sx = 0, sy = 0;
      for (const p of it.relPts){ sx += p[0]; sy += p[1]; }
      sx /= it.relPts.length; sy /= it.relPts.length;

      const tx = it._sx + it.sFixed * sx;
      const ty = it._sy + it.sFixed * sy;

      it.activityText.setAttribute("x", tx);
      it.activityText.setAttribute("y", ty);
    }

    // —— 静止过路者：放置一次 —— //
    function placeStaticPasser(){
      const pos = pickSafePoint();
      if (!pos) return;

      passerEl = document.createElementNS("http://www.w3.org/2000/svg","text");
      passerEl.setAttribute("class","passer");
      passerEl.textContent = PASSERS[randInt(PASSERS.length)];
      passerEl.setAttribute("x", pos.x);
      passerEl.setAttribute("y", pos.y);
      svg.appendChild(passerEl);
    }

    // —— 静止过路者：定期瞬移 & 换词（不移动过渡） —— //
    function schedulePasserUpdates(){
      if (!passerEl) return;
      const hop = () => {
        const pos = pickSafePoint();
        if (pos){
          passerEl.textContent = PASSERS[randInt(PASSERS.length)];
          passerEl.setAttribute("x", pos.x);
          passerEl.setAttribute("y", pos.y);
        }
        // 随机 3–6 秒后再次瞬移
        passerTimer = setTimeout(hop, randRange(PASSER_MIN_MS, PASSER_MAX_MS));
      };
      passerTimer = setTimeout(hop, randRange(PASSER_MIN_MS, PASSER_MAX_MS));
    }

    // 选一个安全点：对每个排斥圆 (cx,cy,R)，需 dist((x,y),(cx,cy)) > R
    function pickSafePoint(){
      const tries = 400;
      for (let i=0;i<tries;i++){
        const x = PASSER_MARGIN + Math.random()*(W - 2*PASSER_MARGIN);
        const y = PASSER_MARGIN + Math.random()*(H - 2*PASSER_MARGIN);
        let ok = true;
        for (const d of exclusionDisks){
          const dx = x - d.cx, dy = y - d.cy;
          if (dx*dx + dy*dy <= d.R*d.R) { ok = false; break; }
        }
        if (ok) return {x,y};
      }
      return null;
    }

    // —— 工具 —— //
    function easeInOutCubic(t){ return (t<0.5) ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2; }
    function angleLerpShortest(a, b, t){
      const TAU = Math.PI * 2;
      let delta = (b - a) % TAU;
      if (delta >  Math.PI) delta -= TAU;
      if (delta < -Math.PI) delta += TAU;
      return a + delta * t;
    }
    function getFarthestPoint(cx,cy, sx,sy, s, relPts){
      let maxD2 = -1, fx = cx, fy = cy;
      for (let i=0;i<relPts.length;i++){
        const dx = relPts[i][0], dy = relPts[i][1];
        const qx = sx + s * dx;
        const qy = sy + s * dy;
        const vx = qx - cx, vy = qy - cy;
        const dd = vx*vx + vy*vy;
        if (dd > maxD2){ maxD2 = dd; fx = qx; fy = qy; }
      }
      return { x: fx, y: fy, dist: Math.sqrt(maxD2) };
    }
    function mapRange(x, inMin, inMax, outMin, outMax){
      if (inMax === inMin) return (outMin + outMax) / 2;
      const t = (x - inMin) / (inMax - inMin);
      return outMin + t * (outMax - outMin);
    }
    function clamp(v, lo, hi){ return Math.min(hi, Math.max(lo, v)); }
  } // render()

  // 首次渲染
  render();
})();
</script>
</body>
</html>
