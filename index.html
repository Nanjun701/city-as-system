<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>Soft Boundary Map</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <h1>Soft Boundary Map</h1>
  <div class="legend" aria-label="Legend">
    <span class="legend-item"><span class="key box"></span>Facilities</span>
    <span class="legend-item"><span class="key shadow"></span>Soft Boundary Field</span>
    <span class="legend-item"><span class="key line"></span>Field Range Measurement</span>
  </div>
  <div id="wrap">
    <svg id="svg" viewBox="0 0 100 100" preserveAspectRatio="none">
      <defs>
        <filter id="shadowBlur" x="-20%" y="-20%" width="140%" height="140%" filterUnits="objectBoundingBox">
          <feGaussianBlur in="SourceGraphic" stdDeviation="7" />
        </filter>
      </defs>
    </svg>
  </div>

  <script>
(() => {
  const COUNT_BASE = 7;
  const SHADOW_ALPHA = 0.1;
  const BLUR_STD = 4;
  const MAX_TRIES = 14000;

  const S_MIN = Math.sqrt(16);
  const S_MAX = Math.sqrt(19);

  const MOVE_MIN = 6000, MOVE_MAX = 11000;
  const HOLD_MIN = 3000, HOLD_MAX = 7000;
  const START_JITTER = 2000;
  const P_MOVE = 0.5;
  const P_DRIFT = 0.25;
  const P_HOLD = 0.25;
  const DRIFT_MAX = Math.PI / 9;

  const PX_MIN = 105, PX_MAX = 118;
  const CM_MIN = 60, CM_MAX = 88;

  // —— 活动图片库 —— //
  const IMG_NAMES = [
    "walk.png","walk2.png","rest.png","exercise.png","date.png","walkdog.png","family.png","babycart.png"
  ];
  const ACT_CHANGE_PROB = 0.5;

  // —— 过路者图片 —— //
  const PASSER_IMGS = ["walk.png","run.png","bike.png","walk2.png", "play.png","walkdog.png", "dog.png"];

  const PASSER_PAD = 6;
  const PASSER_MARGIN = 12;
  const PASSER_MIN_MS = 3000;
  const PASSER_MAX_MS = 6000;

  const wrap = document.getElementById('wrap');
  const svg = document.getElementById('svg');
  const ro = new ResizeObserver(() => render());
  ro.observe(wrap);

  let passerEl = null;
  let passerTimer = null;

  function render() {
    // ✅ 每次渲染前清空（只保留滤镜 defs）
    const defs = svg.querySelector('defs').outerHTML;
    svg.innerHTML = defs;

    // 停止旧计时器
    if (passerTimer) { clearTimeout(passerTimer); passerTimer = null; }

    const W = wrap.clientWidth;
    const H = wrap.clientHeight;
    svg.setAttribute('viewBox', `0 0 ${W} ${H}`);

    const fe = svg.querySelector('#shadowBlur feGaussianBlur');
    if (fe) fe.setAttribute('stdDeviation', String(BLUR_STD));

    const areaScale = (W * H) / (800 * 600);
    const targetCount = clamp(Math.round(COUNT_BASE * Math.sqrt(areaScale)), 3, 20);

    const baseR = Math.min(W, H) * 0.03;
    const BODY_R_MIN = 1.2, BODY_R_MAX = 1.2;

    const animItems = [];
    const exclusionDisks = [];

    const randRange = (a, b) => a + Math.random() * (b - a);
    const randInt = (n) => (Math.random() * n | 0);

    function regularPoly(cx, cy, r, sides, rot) {
      const pts = [];
      for (let i = 0; i < sides; i++) {
        const a = rot + i * (2 * Math.PI / sides);
        pts.push([cx + r * Math.cos(a), cy + r * Math.sin(a)]);
      }
      return pts;
    }

    function tryPlace() {
      const placed = [];
      let tries = 0;

      while (placed.length < targetCount && tries < MAX_TRIES) {
        tries++;

        const bodyR = baseR * randRange(BODY_R_MIN, BODY_R_MAX);
        const sFixed = randRange(S_MIN, S_MAX);
        const shadowR = bodyR * sFixed;

        const sides = 4 + (Math.random() * 3 | 0);
        const rot = Math.random() * Math.PI;

        const margin = bodyR + shadowR + 2;
        const cx = margin + Math.random() * (W - 2 * margin);
        const cy = margin + Math.random() * (H - 2 * margin);

        if (cx < bodyR || cx > W - bodyR || cy < bodyR || cy > H - bodyR) continue;

        let ok = true;
        for (const o of placed) {
          const dc = Math.hypot(cx - o.cx, cy - o.cy);
          if (dc < (bodyR + o.bodyR)) { ok = false; break; }
          if (Math.abs(dc - o.bodyR) < (bodyR + o.shadowR)) { ok = false; break; }
          if (Math.abs(dc - bodyR) < (shadowR + o.bodyR)) { ok = false; break; }
          if (dc - (bodyR + o.bodyR) < (shadowR + o.shadowR)) { ok = false; break; }
        }
        if (!ok) continue;

        const absPts = regularPoly(cx, cy, bodyR, sides, rot);
        const relPts = absPts.map(([px, py]) => [px - cx, py - cy]);
        const d = "M" + absPts.map(p => p.join(",")).join(" L ") + " Z";

        // 阴影
        const shadowPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
        shadowPath.setAttribute("d", d);
        shadowPath.setAttribute("fill", `rgba(0,0,0,${SHADOW_ALPHA})`);
        shadowPath.setAttribute("filter", "url(#shadowBlur)");
        svg.appendChild(shadowPath);

        // 实体
        const body = document.createElementNS("http://www.w3.org/2000/svg", "path");
        body.setAttribute("d", d);
        body.setAttribute("fill", "#fff");
        body.setAttribute("stroke", "#000");
        body.setAttribute("stroke-width", "0.2");
        svg.appendChild(body);

        // 标尺
        const rulerLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
        rulerLine.setAttribute("stroke", "red");
        rulerLine.setAttribute("stroke-width", "0.5");
        svg.appendChild(rulerLine);

        const rulerLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
        rulerLabel.setAttribute("fill", "#000");
        rulerLabel.setAttribute("font-size", "10");
        rulerLabel.setAttribute("text-anchor", "middle");
        svg.appendChild(rulerLabel);

        // —— 阴影内活动图片 —— //
        const activityImg = document.createElementNS("http://www.w3.org/2000/svg", "image");
        const imgName = IMG_NAMES[randInt(IMG_NAMES.length)];
        activityImg.setAttribute("href", `assets/img/${imgName}`);
        activityImg.setAttribute("class", "activity-img");
        activityImg.setAttribute("width", "30");
        activityImg.setAttribute("height", "30");
        activityImg.style.mixBlendMode = "multiply";
        svg.appendChild(activityImg);

        const theta0 = Math.random() * Math.PI * 2;
        const sx0 = cx + bodyR * Math.cos(theta0);
        const sy0 = cy + bodyR * Math.sin(theta0);
        shadowPath.setAttribute("transform", `translate(${sx0},${sy0}) scale(${sFixed}) translate(${-cx},${-cy})`);

        const now = performance.now();
        const { type, target, dur } = pickNextSegment(theta0);
        placed.push({ cx, cy, bodyR, shadowR });
        animItems.push({
          shadowPath,
          cx, cy,
          rPath: bodyR,
          thetaStart: theta0,
          thetaTarget: target,
          segT0: now + randRange(0, START_JITTER),
          segDur: dur,
          segType: type,
          sFixed,
          relPts,
          rulerLine, rulerLabel,
          activityImg,
          _sx: sx0, _sy: sy0
        });

        exclusionDisks.push({ cx, cy, R: bodyR * (1 + sFixed) + PASSER_PAD });
      }
      return placed.length === targetCount;
    }

    function pickNextSegment(thetaStart) {
      const r = Math.random();
      if (r < P_MOVE) {
        return { type: "MOVE", target: Math.random() * Math.PI * 2, dur: randRange(MOVE_MIN, MOVE_MAX) };
      } else if (r < P_MOVE + P_DRIFT) {
        const delta = randRange(-DRIFT_MAX, DRIFT_MAX);
        const TAU = Math.PI * 2;
        let target = (thetaStart + delta) % TAU; if (target < 0) target += TAU;
        return { type: "DRIFT", target, dur: randRange(MOVE_MIN, MOVE_MAX) };
      } else {
        return { type: "HOLD", target: thetaStart, dur: randRange(HOLD_MIN, HOLD_MAX) };
      }
    }

    // ✅ 只执行一次生成逻辑，不重复叠加
    tryPlace();
    startAnim();
    placeStaticPasser();
    schedulePasserUpdates();

function startAnim() {
  function tick(now) {
    for (const it of animItems) {
      const phase = now - it.segT0;

      if (phase < 0) continue; // 等待下一段开始

      const t = Math.min(1, phase / it.segDur);
      const e = easeInOutCubic(t);
      const theta = angleLerpShortest(it.thetaStart, it.thetaTarget, e);
      update(it, theta);

      // ✅ 持续循环：一段结束后立刻接下一段
      if (phase > it.segDur) {
        it.thetaStart = it.thetaTarget;
        const nxt = pickNextSegment(it.thetaStart);
        it.thetaTarget = nxt.target;
        it.segDur = nxt.dur;
        it.segT0 = now; // ⚠️关键：立刻开始下一段，不要延迟
        it.segType = nxt.type;

        if (Math.random() < ACT_CHANGE_PROB) {
          const newImg = IMG_NAMES[randInt(IMG_NAMES.length)];
          it.activityImg.setAttribute("href", `assets/img/${newImg}`);
        }
      }
    }
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);
}


    function update(it, theta) {
      it._sx = it.cx + it.rPath * Math.cos(theta);
      it._sy = it.cy + it.rPath * Math.sin(theta);
      it.shadowPath.setAttribute(
        "transform",
        `translate(${it._sx},${it._sy}) scale(${it.sFixed}) translate(${-it.cx},${-it.cy})`
      );

      const far = getFarthestPoint(it.cx, it.cy, it._sx, it._sy, it.sFixed, it.relPts);
      it.rulerLine.setAttribute("x1", it.cx);
      it.rulerLine.setAttribute("y1", it.cy);
      it.rulerLine.setAttribute("x2", far.x);
      it.rulerLine.setAttribute("y2", far.y);
      const midx = it.cx + (far.x - it.cx) * 0.6, midy = it.cy + (far.y - it.cy) * 0.6;
      it.rulerLabel.setAttribute("x", midx);
      it.rulerLabel.setAttribute("y", midy);
      const cm = clamp(mapRange(far.dist, PX_MIN, PX_MAX, CM_MIN, CM_MAX), CM_MIN, CM_MAX);
      it.rulerLabel.textContent = cm.toFixed(1) + " cm";

      let sx = 0, sy = 0;
      for (const p of it.relPts) { sx += p[0]; sy += p[1]; }
      sx /= it.relPts.length; sy /= it.relPts.length;
      const tx = it._sx + it.sFixed * sx;
      const ty = it._sy + it.sFixed * sy;
      it.activityImg.setAttribute("x", tx - 11);
      it.activityImg.setAttribute("y", ty - 11);
    }

    // —— 外部过路者改为图片 —— //
    function placeStaticPasser() {
      const pos = pickSafePoint();
      if (!pos) return;
      passerEl = document.createElementNS("http://www.w3.org/2000/svg", "image");
      const imgName = PASSER_IMGS[randInt(PASSER_IMGS.length)];
      passerEl.setAttribute("href", `assets/img/${imgName}`);
      passerEl.setAttribute("width", "30");
      passerEl.setAttribute("height", "30");
      passerEl.style.mixBlendMode = "multiply";
      passerEl.setAttribute("x", pos.x);
      passerEl.setAttribute("y", pos.y);
      passerEl.setAttribute("class", "passer-img");
      svg.appendChild(passerEl);
    }

    function schedulePasserUpdates() {
      if (!passerEl) return;
      const hop = () => {
        const pos = pickSafePoint();
        if (pos) {
          const newImg = PASSER_IMGS[randInt(PASSER_IMGS.length)];
          passerEl.setAttribute("href", `assets/img/${newImg}`);
          passerEl.setAttribute("x", pos.x);
          passerEl.setAttribute("y", pos.y);
        }
        passerTimer = setTimeout(hop, randRange(PASSER_MIN_MS, PASSER_MAX_MS));
      };
      passerTimer = setTimeout(hop, randRange(PASSER_MIN_MS, PASSER_MAX_MS));
    }

function pickSafePoint() {
  const tries = 400;
  const IMG_SIZE = 30; // passer 图片大小
  const EDGE_PADDING = 8; // 额外留一点边距

  for (let i = 0; i < tries; i++) {
    // ✅ 让随机点始终留出半个图片的宽高 + padding
    const x = EDGE_PADDING + IMG_SIZE / 2 + Math.random() * (W - IMG_SIZE - 2 * EDGE_PADDING);
    const y = EDGE_PADDING + IMG_SIZE / 2 + Math.random() * (H - IMG_SIZE - 2 * EDGE_PADDING);

    let ok = true;
    for (const d of exclusionDisks) {
      const dx = x - d.cx, dy = y - d.cy;
      if (dx * dx + dy * dy <= d.R * d.R) { ok = false; break; }
    }
    if (ok) return { x, y };
  }
  return null;
}


    function easeInOutCubic(t) { return (t < 0.5) ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2; }
    function angleLerpShortest(a, b, t) {
      const TAU = Math.PI * 2;
      let delta = (b - a) % TAU;
      if (delta > Math.PI) delta -= TAU;
      if (delta < -Math.PI) delta += TAU;
      return a + delta * t;
    }
    function getFarthestPoint(cx, cy, sx, sy, s, relPts) {
      let maxD2 = -1, fx = cx, fy = cy;
      for (let i = 0; i < relPts.length; i++) {
        const dx = relPts[i][0], dy = relPts[i][1];
        const qx = sx + s * dx;
        const qy = sy + s * dy;
        const vx = qx - cx, vy = qy - cy;
        const dd = vx * vx + vy * vy;
        if (dd > maxD2) { maxD2 = dd; fx = qx; fy = qy; }
      }
      return { x: fx, y: fy, dist: Math.sqrt(maxD2) };
    }
    function mapRange(x, inMin, inMax, outMin, outMax) {
      if (inMax === inMin) return (outMin + outMax) / 2;
      const t = (x - inMin) / (inMax - inMin);
      return outMin + t * (outMax - outMin);
    }
    function clamp(v, lo, hi) { return Math.min(hi, Math.max(lo, v)); }
  }

  render();
})();


  </script>
</body>
</html>
